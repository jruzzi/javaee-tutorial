type=page
status=published
title=Creating String-Based Queries
~~~~~~
Creating String-Based Queries
=============================
2017-07-17T15:27:51Z

[[top]]

[width="100%",cols="50%,45%,^5%",]
|=======================================================================
|*Java Platform, Enterprise Edition The Java EE Tutorial* +
*Release 8 Java Platform, Enterprise Edition* +
E63026-01
|
|link:toc.html[image:img/toc.gif[Go To Table Of
Contents] +
Contents]
|=======================================================================

'''''

[cols="^5%,^5%,90%",]
|=======================================================================
|link:persistence-string-queries001.html[image:img/leftnav.gif[Previous] +
Previous] 
|link:persistence-string-queries003.html[image:img/rightnav.gif[Next] +
Next] | 
|=======================================================================


[[GKJBQ]]

[[creating-string-based-queries]]
41.2 Creating String-Based Queries
----------------------------------

To create a string-based query, specify the attribute names of entity
classes directly as strings, instead of specifying the attributes of the
metamodel class. For example, this query finds all `Pet` entities where
the value of the `name` attribute is `Fido`:

[source,oac_no_warn]
----
CriteriaQuery<Pet> cq = cb.createQuery(Pet.class);
Root<Pet> pet = cq.from(Pet.class);
cq.where(cb.equal(pet.get("name"), "Fido"));
----

The name of the attribute is specified as a string. This query is the
equivalent of the following metamodel query:

[source,oac_no_warn]
----
CriteriaQuery<Pet> cq = cb.createQuery(Pet.class);
Metamodel m = em.getMetamodel();
EntityType<Pet> Pet_ = m.entity(Pet.class);
Root<Pet> pet = cq.from(Pet.class);
cq.where(cb.equal(pet.get(Pet_.name), "Fido"));
----

 +

[width="100%",cols="100%",]
|=======================================================================
a|
Note:

Type mismatch errors in string-based queries will not appear until the
code is executed at runtime, unlike in the above metamodel query, where
type mismatches will be caught at compile time.

|=======================================================================

 +

Joins are specified in the same way:

[source,oac_no_warn]
----
CriteriaQuery<Pet> cq = cb.createQuery(Pet.class);
Root<Pet> pet = cq.from(Pet.class);
Join<Owner, Address> address = pet.join("owners").join("addresses");
----

All the conditional expressions, method expressions, path navigation
methods, and result restriction methods used in metamodel queries can
also be used in string-based queries. In each case, the attributes are
specified using strings. For example, here is a string-based query that
uses the `in` expression:

[source,oac_no_warn]
----
CriteriaQuery<Pet> cq = cb.createQuery(Pet.class);
Root<Pet> pet = cq.from(Pet.class);
cq.where(pet.get("color").in("brown", "black"));
----

Here is a string-based query that orders the results in descending order
by date:

[source,oac_no_warn]
----
CriteriaQuery<Pet> cq = cb.createQuery(Pet.class);
Root<Pet> pet = cq.from(Pet.class);
cq.select(pet);
cq.orderBy(cb.desc(pet.get("birthday")));
----

'''''

[width="100%",cols="^5%,^5%,^10%,^65%,^10%,^5%",]
|====================================================================
|link:persistence-string-queries001.html[image:img/leftnav.gif[Previous] +
Previous] 
|link:persistence-string-queries003.html[image:img/rightnav.gif[Next] +
Next]
|
|image:img/oracle.gif[Oracle Logo]
link:cpyr.html[ +
Copyright © 2014, 2017, Oracle and/or its affiliates. All rights reserved.]
|
|link:toc.html[image:img/toc.gif[Go To Table Of
Contents] +
Contents]
|====================================================================
