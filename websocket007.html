
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Using Encoders and Decoders</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet">
  </head>
  <body>

<div id="preamble">
<div class="sectionbody">
<table id="top" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 45%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Java Platform, Enterprise Edition The Java EE Tutorial</strong><br>
<strong>Release 8 Java Platform, Enterprise Edition</strong><br>
E63026-01</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="toc.html"><span class="image"><img src="img/toc.gif" alt="Go To Table Of Contents"></span><br>
Contents</a></p></td>
</tr>
</tbody>
</table>
<hr>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 90%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="websocket006.html"><span class="image"><img src="img/leftnav.gif" alt="Previous"></span><br>
Previous</a> </p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="websocket008.html"><span class="image"><img src="img/rightnav.gif" alt="Next"></span><br>
Next</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="using-encoders-and-decoders">18.7 Using Encoders and Decoders</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Java API for WebSocket provides support for converting between
WebSocket messages and custom Java types using encoders and decoders. An
encoder takes a Java object and produces a representation that can be
transmitted as a WebSocket message; for example, encoders typically
produce JSON, XML, or binary representations. A decoder performs the
reverse function; it reads a WebSocket message and creates a Java
object.</p>
</div>
<div class="paragraph">
<p>This mechanism simplifies WebSocket applications, because it decouples
the business logic from the serialization and deserialization of
objects.</p>
</div>
<div class="paragraph">
<p>The following topics are addressed here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#CIHBIGBI">Section 18.7.1, "Implementing Encoders to Convert Java
Objects into WebSocket Messages"</a></p>
</li>
<li>
<p><a href="#CIHGDJFG">Section 18.7.2, "Implementing Decoders to Convert
WebSocket Messages into Java Objects"</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="implementing-encoders-to-convert-java-objects-into-websocket-messages">18.7.1 Implementing Encoders to Convert Java Objects into WebSocketMessages</h3>
<div class="paragraph">
<p>The procedure to implement and use encoders in endpoints follows.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Implement one of the following interfaces:</p>
<div class="ulist">
<ul>
<li>
<p><code>Encoder.Text&lt;T&gt;</code> for text messages</p>
</li>
<li>
<p><code>Encoder.Binary&lt;T&gt;</code> for binary messages</p>
<div class="paragraph">
<p>These interfaces specify the <code>encode</code> method. Implement an encoder class
for each custom Java type that you want to send as a WebSocket message.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Add the names of your encoder implementations to the <code>encoders</code>
optional parameter of the <code>ServerEndpoint</code> annotation.</p>
</li>
<li>
<p>Use the <code>sendObject(Object data)</code> method of the
<code>RemoteEndpoint.Basic</code> or <code>RemoteEndpoint.Async</code> interfaces to send your
objects as messages. The container looks for an encoder that matches
your type and uses it to convert the object to a WebSocket message.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, if you have two Java types (<code>MessageA</code> and <code>MessageB</code>) that
you want to send as text messages, implement the
<code>Encoder.Text&lt;MessageA&gt;</code> and <code>Encoder.Text&lt;MessageB&gt;</code> interfaces as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">public class MessageATextEncoder implements Encoder.Text&lt;MessageA&gt; {
   @Override
   public void init(EndpointConfig ec) { }
   @Override
   public void destroy() { }
   @Override
   public String encode(MessageA msgA) throws EncodeException {
      // Access msgA's properties and convert to JSON text...
      return msgAJsonString;
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implement <code>Encoder.Text&lt;MessageB&gt;</code> similarly. Then, add the <code>encoders</code>
parameter to the <code>ServerEndpoint</code> annotation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">@ServerEndpoint(
   value = "/myendpoint",
   encoders = { MessageATextEncoder.class, MessageBTextEncoder.class }
)
public class EncEndpoint { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, you can send <code>MessageA</code> and <code>MessageB</code> objects as WebSocket
messages using the <code>sendObject</code> method as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">MessageA msgA = new MessageA(...);
MessageB msgB = new MessageB(...);
session.getBasicRemote.sendObject(msgA);
session.getBasicRemote.sendObject(msgB);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As in this example, you can have more than one encoder for text messages
and more than one encoder for binary messages. Like endpoints, encoder
instances are associated with one and only one WebSocket connection and
peer, so there is only one thread executing the code of an encoder
instance at any given time.</p>
</div>
</div>
<div class="sect2">
<h3 id="implementing-decoders-to-convert-websocket-messages-into-java-objects">18.7.2 Implementing Decoders to Convert WebSocket Messages into JavaObjects</h3>
<div class="paragraph">
<p>The procedure to implement and use decoders in endpoints follows.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Implement one of the following interfaces:</p>
<div class="ulist">
<ul>
<li>
<p><code>Decoder.Text&lt;T&gt;</code> for text messages</p>
</li>
<li>
<p><code>Decoder.Binary&lt;T&gt;</code> for binary messages</p>
<div class="paragraph">
<p>These interfaces specify the <code>willDecode</code> and <code>decode</code> methods.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>Note:</p>
</div>
<div class="paragraph">
<p>Unlike with encoders, you can specify at most one decoder for binary
messages and one decoder for text messages.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="literalblock">
<div class="content">
<pre> +
2.  Add the names of your decoder implementations to the `decoders`
optional parameter of the `ServerEndpoint` annotation.
3.  Use the `OnMessage` annotation in the endpoint to designate a method
that takes your custom Java type as a parameter. When the endpoint
receives a message that can be decoded by one of the decoders you
specified, the container calls the method annotated with `@OnMessage`
that takes your custom Java type as a parameter if this method exists.</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, if you have two Java types (<code>MessageA</code> and <code>MessageB</code>) that
you want to send and receive as text messages, define them so that they
extend a common class (<code>Message</code>). Because you can only define one
decoder for text messages, implement a decoder for the <code>Message</code> class
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">public class MessageTextDecoder implements Decoder.Text&lt;Message&gt; {
   @Override
   public void init(EndpointConfig ec) { }
   @Override
   public void destroy() { }
   @Override
   public Message decode(String string) throws DecodeException {
      // Read message...
      if ( /* message is an A message */ )
         return new MessageA(...);
      else if ( /* message is a B message */ )
         return new MessageB(...);
   }
   @Override
   public boolean willDecode(String string) {
      // Determine if the message can be converted into either a
      // MessageA object or a MessageB object...
      return canDecode;
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, add the <code>decoder</code> parameter to the <code>ServerEndpoint</code> annotation as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">@ServerEndpoint(
   value = "/myendpoint",
   encoders = { MessageATextEncoder.class, MessageBTextEncoder.class },
   decoders = { MessageTextDecoder.class }
)
public class EncDecEndpoint { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, define a method in the endpoint class that receives <code>MessageA</code> and
<code>MessageB</code> objects as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">@OnMessage
public void message(Session session, Message msg) {
   if (msg instanceof MessageA) {
      // We received a MessageA object...
   } else if (msg instanceof MessageB) {
      // We received a MessageB object...
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like endpoints, decoder instances are associated with one and only one
WebSocket connection and peer, so there is only one thread executing the
code of a decoder instance at any given time.</p>
</div>
<hr>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 10%;">
<col style="width: 65%;">
<col style="width: 10%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="websocket006.html"><span class="image"><img src="img/leftnav.gif" alt="Previous"></span><br>
Previous</a> </p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="websocket008.html"><span class="image"><img src="img/rightnav.gif" alt="Next"></span><br>
Next</a></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="image"><img src="img/oracle.gif" alt="Oracle Logo"></span>
<a href="cpyr.html"><br>
Copyright © 2014, 2017, Oracle and/or its affiliates. All rights reserved.</a></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="toc.html"><span class="image"><img src="img/toc.gif" alt="Go To Table Of Contents"></span><br>
Contents</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

  </body>
</html>